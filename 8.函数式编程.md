
函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，
因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点：允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

Python对函数编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

## 一、高阶函数

接受函数作为参数的函数，称为高阶函数。函数式编程就是指这种高度抽象的编程范式。

- 变量可以指向函数

```python
>>> abs(-1024)
1024
>>> abs
<built-in function abs>
>>> x = abs
>>> x
<built-in function abs>
>>> x(-1024)
1024
```

- 函数名也是变量

函数名其实就是指向函数的变量。

```python
>>> abs = 10
>>> abs(-1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
>>> abs + 20
30
```

- 传入函数

```
>>> def add(x, y, f):
...     return f(x) + f(y)
...
>>> add(-1025, 256, abs)
1281
```


### (1).map/reduce

map()函数接受两个参数，一个是函数，一个是Iterable。map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iteror返回。

list()可以把Iterator序列计算出来并返回一个list。

```python
>>> def f(x):
...     return x *x
...
>>> r = map(f, [1,2,3,4,5])
>>> list(r)
[1, 4, 9, 16, 25]
>>> # 转成字符串
>>> list(map(str, [1,2,3,4,5]))
['1', '2', '3', '4', '5']
```

reduce函数把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

```python
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
... 
>>> reduce(add, [1, 3, 5, 7, 9])
25
>>> 
>>> def fn(x, y):
...     return x * 10 + y
... 
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```

### (2).filter

filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

```python
>>> def is_odd(n):
...     return n % 2 == 1
... 
>>> list(filter(is_odd, [1, 2, 4, 5, 6, 8, 9, 10, 15]))
[1, 5, 9, 15]
>>> def not_empty(s):
...     return s and s.strip()
... 
>>> list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))
['A', 'B', 'C']
```

打印素数：

```python
>>> def _odd_iter():
...     n = 1
...     while True:
...             n = n + 2
...             yield n
... 
>>> def _not_divisible(n):
...     return lambda x: x % n >0
... 
>>> def primes():
...     yield 2
...     it = _odd_iter()
...     while True:
...             n = next(it)
...             yield n
...             it = filter(_not_divisible(n), it)
... 
>>> for n in primes():
...     if n < 50:
...             print(n)
...     else:
...             break
... 
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
```

### (3).sorted

